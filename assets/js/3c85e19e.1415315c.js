"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[640],{7926:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=n(7462),i=(n(7294),n(3905)),l=n(814),o=n(7784);const r={sidebar_position:5},p="QML Plugin",s={unversionedId:"features/qmlplugin",id:"features/qmlplugin",title:"QML Plugin",description:"With this feature you can use a qml version of your interface as a [Qml plugin](https://doc.qt.io/qtcreator/creator-qml-modules-with-plugins.html.",source:"@site/docs/features/qmlplugin.md",sourceDirName:"features",slug:"/features/qmlplugin",permalink:"/template-qtcpp/features/qmlplugin",draft:!1,editUrl:"https://github.com/apigear-io/template-qtcpp/edit/main/docs/features/qmlplugin.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1693991262,formattedLastUpdatedAt:"Sep 6, 2023",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Monitor",permalink:"/template-qtcpp/features/monitor"}},d={},m=[{value:"File overview for module",id:"file-overview-for-module",level:3},{value:"QML API",id:"qml-api",level:3},{value:"QML Wrappers",id:"qml-wrappers",level:3},{value:"Providing backend to QML Wrapper.",id:"providing-backend-to-qml-wrapper",level:3},{value:"Paths",id:"paths",level:3}],c={toc:m},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"qml-plugin"},"QML Plugin"),(0,i.kt)("p",null,"With this feature you can use a qml version of your interface as a ","[Qml plugin]","(",(0,i.kt)("a",{parentName:"p",href:"https://doc.qt.io/qtcreator/creator-qml-modules-with-plugins.html"},"https://doc.qt.io/qtcreator/creator-qml-modules-with-plugins.html"),".\nIt provides qml -available version of you interfaces and factory implementation for interfaces and factories for structures. It creates a qml module for your interface."),(0,i.kt)("h3",{id:"file-overview-for-module"},"File overview for module"),(0,i.kt)("p",null,"With an example API"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(l.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},o.Z)),(0,i.kt)("p",null,"the following file structure will be generated. The purpose and content of each file is explained below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{9}","{9}":!0},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2523 \ud83d\udcc2qt_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2io_world\n \u2503 \u2503 \u2523 \ud83d\udcc2api\n \u2503 \u2503 ...\n \u2503 \u2503 \u2523 \ud83d\udcc2qmlplugin\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcapifactory.cpp\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcapifactory.h\n \u2503 \u2503 \u2503  \u2517 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcqml_api.cpp\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcqml_api.h\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcqmlhello.cpp\n \u2503 \u2503 \u2503  \u2523 \ud83d\udcdcqmlhello.h\n")),(0,i.kt)("h3",{id:"qml-api"},"QML API"),(0,i.kt)("p",null,"To avoid possible namespace collision between different modules we use ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_NAMED_ELEMENT()")," with module name and element name for all registering objects, like e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_NAMED_ELEMENT(IoWorldWhen)")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"When")," enum."),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcqml_api.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcqml_api.cpp")," contain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the enum wrapper for enum registration, which adds only QML macros for registering enum from ",(0,i.kt)("inlineCode",{parentName:"li"},"api")," library.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'struct ForeignWhen : public QObject\n{\n    Q_OBJECT\n    QML_FOREIGN(When)\n    QML_NAMED_ELEMENT(IoWorldWhen)\n    QML_UNCREATABLE("This is enum class")\n    QML_ADDED_IN_VERSION(1,0)\n};\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the factory for uncreatable otherwise in QML structures")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class IO_WORLD_QML_EXPORT MessageFactory : public QObject {\n    Q_OBJECT\n    QML_ADDED_IN_VERSION(1,0)\n    QML_NAMED_ELEMENT(IoWorldMessageFactory)\n    QML_SINGLETON\npublic:\n    Q_INVOKABLE io_world::Message create(QString in_content);\n};\n")),(0,i.kt)("p",null,"All factories are ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_SINGLETONS"),", so you don't have to create any instance of it, just call ",(0,i.kt)("inlineCode",{parentName:"p"},"var myInstance = IoWorldMessageFactory.create(...)")," in your qml code.\nThe create function requires input parameters for all members of the created structure."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The qml plugin uses the version information form helloworld.module.yaml to register types, both with the ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_ADDED_IN_VERSION")," and with ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_add_qml_module")," in CMakeLists.txt. Use this version when importing your module in qml, here ",(0,i.kt)("inlineCode",{parentName:"p"},"import io_world 1.0"))),(0,i.kt)("h3",{id:"qml-wrappers"},"QML Wrappers"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcqmlhello.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcqmlhello.cpp")," contain a qml wrapper for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface.",(0,i.kt)("br",null),"\nThe qml wrapper requires providing an implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractHello")," instance. For that we use the factory described in ","[api]"," module with ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdciapifactory.h")," and implemented in this module in (",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcapifactory.h"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcapifactory.cpp"),"). The functionality is explained ",(0,i.kt)("a",{parentName:"p",href:"qmlplugin#providing-backend-to-qml-wrapper"},"below"),"."),(0,i.kt)("p",null,"The QML wrapper (simplified version)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'showLineNumbers  title="qmlhello.h"',showLineNumbers:!0,"":!0,title:'"qmlhello.h"'},"class IO_WORLD_QML_EXPORT QMLHello : public AbstractHello\n{\n    Q_OBJECT\n    QML_NAMED_ELEMENT(IoWorldHello)\n    ...\n    Q_PROPERTY(Message last READ last WRITE setLast NOTIFY lastChanged)\n    ...\n    Q_INVOKABLE int say(const Message& msg, When::WhenEnum when) override;\n    ...\nQ_SIGNALS:\n    void lastChanged(const Message& last);\n}\n")),(0,i.kt)("p",null,"The qml wrapper makes the interface usable from qml:",(0,i.kt)("br",null),"\nLine 6 shows exposed properties, with emitting signal on property changed from qml (",(0,i.kt)("inlineCode",{parentName:"p"},"NOTIFY lastChanged"),") - hence overriding signal for property changed (line 11). ",(0,i.kt)("br",null),"\nLine 8 shows the function exposed as a callable from qml.  ",(0,i.kt)("br",null),"\nThe wrapper forwards the calls to backend and all the signals from backend to qml wrapper."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The signals defined in the api shall be emitted by the backend and handled in qml, not the other way around. When the signal is emitted in qml, it won't reach the backend implementation.")),(0,i.kt)("p",null,"To use QMLHello you just need to create an instance of it in your QML code with a proper name (the one used in ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_NAMED_ELEMENT"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"import QtQuick 2.15\nimport QtQuick.Layouts 1.2\nimport io_world 1.0\n\nApplicationWindow {\n    id: appWindow\n    visible: true\n    width: 300\n    height: 300\n\n    IoWorldHello { id: qmlIoWorldHello }\n")),(0,i.kt)("h3",{id:"providing-backend-to-qml-wrapper"},"Providing backend to QML Wrapper."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"QmlHello")," is instantiated in qml without any handle to get or set the backend. Therefore, the global ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiFactory")," class of ",(0,i.kt)("inlineCode",{parentName:"p"},"IApiFactory")," type is added to provide a flexible and extensible way to create it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"QmlHello")," class creates the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," backend object by itself using the global ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiFactory"),". By providing your ",(0,i.kt)("inlineCode",{parentName:"p"},"IApiFactory")," implementation, you will be able to use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," backend of your choice. "),(0,i.kt)("p",null,"Here is an example code snippet that shows how to prepare your ",(0,i.kt)("inlineCode",{parentName:"p"},"IApiFactory")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="io_world/customfactory.h"',title:'"io_world/customfactory.h"'},'#pragma once\n\n#include "io_world/api/iapifactory.h"\n// #include "your CustomHello header file"\n#include <QtCore>\n\nclass CustomFactory : public QObject, public IApiFactory\n{\npublic:\n    CustomFactory(..., QObject *parent = nullptr); //provide any extra resources your factory needs.\n\n    std::shared_ptr<AbstractHello> createHello(QObject *parent = nullptr) override\n    {\n        return make_shared<CustomHello>(...); // provide any resource your CustomHello needs.\n    }\n};\n\n')),(0,i.kt)("p",null,"and set in code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="main.cpp"',title:'"main.cpp"'},'#include "io_world/api/apifactory.h"\n#include "io_world/customfactory.h"\n\n#include <QtCore>\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n\nint main(int argc, char *argv[]){\n\n    io_world::CustomFactory io_worldFactory();\n    // Setting the CustomFactory as a global factory. From now, each qml object will create backend with it.\n    io_world::ApiFactory::set(&io_worldFactory); \n\n    // Starting your application after setting the factory.\n    const QUrl url(QStringLiteral("qrc:/main.qml"));\n    QGuiApplication app(argc, argv);\n    QQmlApplicationEngine engine;\n\n    engine.load(url);\n    ...\n')),(0,i.kt)("p",null,"this way, on every ",(0,i.kt)("inlineCode",{parentName:"p"},"QmlHello")," instantiation, your ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomFactory::createHello")," is called, and the returned object is used by ",(0,i.kt)("inlineCode",{parentName:"p"},"QmlHello"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"You can check the ",(0,i.kt)("inlineCode",{parentName:"p"},"qml example")," or factories provided by other features. For instance ",(0,i.kt)("a",{parentName:"p",href:"/template-qtcpp/features/olink"},"olink"),".")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Your IApiFactory implementation needs to be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiFactory")," once, before the QML file is loaded.")),(0,i.kt)("h3",{id:"paths"},"Paths"),(0,i.kt)("p",null,"If you run your application outside of ",(0,i.kt)("em",{parentName:"p"},"Qt Creator")," you need to add the import paths (paths where the plugins are) to runtime.\nYou can either set the QML_IMPORT_PATH and QML2_IMPORT_PATH environment variables - for ad-hoc import paths (for debugging or testing) or use the ",(0,i.kt)("inlineCode",{parentName:"p"},"QQmlEngine::addImportPath()")," function for fixed import paths that should always be available. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    QGuiApplication app(argc, argv);\n    QQmlApplicationEngine engine;\n    app.addLibraryPath(the-directory);\n")),(0,i.kt)("p",null,"Usually the plugins are located in your ",(0,i.kt)("inlineCode",{parentName:"p"},"CMAKE_BINARY_DIR"),' in the target folder.\nIn our example code that would be "your-build-dir/io/world/qmlplugin" folder.'),(0,i.kt)("p",null,"Read more on ",(0,i.kt)("a",{parentName:"p",href:"https://doc.qt.io/qt-6/qtqml-syntax-imports.html#qml-import-path"},"import paths")))}h.isMDXComponent=!0}}]);