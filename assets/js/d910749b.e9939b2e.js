"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[36],{7849:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=n(7462),o=(n(7294),n(3905)),r=n(814),i=n(7784);n.p;const l={sidebar_position:3},s="MQTT",p={unversionedId:"features/mqtt",id:"features/mqtt",title:"MQTT",description:"This is an experimental feature. It contains smallest working set of functionalities to adapt the generated interface for using over the network with MQTT protocol.",source:"@site/docs/features/mqtt.md",sourceDirName:"features",slug:"/features/mqtt",permalink:"/template-qtcpp/features/mqtt",draft:!1,editUrl:"https://github.com/apigear-io/template-qtcpp/edit/main/docs/features/mqtt.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1698742474,formattedLastUpdatedAt:"Oct 31, 2023",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Stubs",permalink:"/template-qtcpp/features/stubs"},next:{title:"Olink",permalink:"/template-qtcpp/features/olink"}},d={},c=[{value:"Before Start - prepare QMqtt Module",id:"before-start---prepare-qmqtt-module",level:3},{value:"File overview for module",id:"file-overview-for-module",level:2},{value:"Qt apigear - The Network Layer",id:"qt-apigear---the-network-layer",level:3},{value:"MQTT Client Adapter",id:"mqtt-client-adapter",level:3},{value:"Properties",id:"properties",level:4},{value:"Operations",id:"operations",level:4},{value:"Signals",id:"signals",level:4},{value:"Use <code>MqttHello</code>",id:"use-mqtthello",level:4},{value:"MQTT Server Adapter",id:"mqtt-server-adapter",level:3},{value:"Properties",id:"properties-1",level:4},{value:"Operations",id:"operations-1",level:4},{value:"Signals",id:"signals-1",level:4},{value:"Use <code>MqttHelloAdapter</code>",id:"use-mqtthelloadapter",level:4},{value:"MQTT Factory - for QML usage",id:"mqtt-factory---for-qml-usage",level:3},{value:"MQTT Messages",id:"mqtt-messages",level:3}],m={toc:c},h="wrapper";function u(e){let{components:t,...l}=e;return(0,o.kt)(h,(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mqtt"},"MQTT"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"This is an experimental feature. It contains smallest working set of functionalities to adapt the generated interface for using over the network with MQTT protocol.\nIt doesn't include the security. The error handling is minimal. It is not production ready.\nPlease also check issues on github for this template.")),(0,o.kt)("p",null,"This feature purpose is not only to help you introduce MQTT protocol into your project, but also show that an existing protocol can be adapted for sharing your data in your ecosystem. When going through this document you may notice this implementation contains general client/server adapters in \ud83d\udcc2hello-world/apigear/mqtt\nand an interface specific part generated from templates for each interface in  \ud83d\udcc2hello-world/qt_hello_world/io_world/mqtt. ",(0,o.kt)("br",null)," ",(0,o.kt)("br",null),"\nThis feature provides a ",(0,o.kt)("em",{parentName:"p"},"client")," and a ",(0,o.kt)("em",{parentName:"p"},"server")," adapter for your interfaces for the MQTT protocol. It allows you to connect different applications in the same or different technologies (check all of our ",(0,o.kt)("a",{parentName:"p",href:"https://docs.apigear.io/docs/category/sdk-templates"},"templates"),").",(0,o.kt)("br",null),"\nUse an ",(0,o.kt)("em",{parentName:"p"},"Mqtt client")," instead of your interface implementation to connect to be able to receive data from remote service.  Use an ",(0,o.kt)("em",{parentName:"p"},"Mqtt server adapter")," to expose your interface implementation as a remote service.",(0,o.kt)("br",null)),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The MQTT broker is not provided with implementation. To be able to run client and service you need to run a broker of your choice.")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"}," In this library we use STL classes in public interfaces.\nWe assume that this library is built from source (configuration provided by generated CMakeLists).\nOtherwise, it has to be ensured that your build configuration matches the library build configuration.")),(0,o.kt)("h3",{id:"before-start---prepare-qmqtt-module"},"Before Start - prepare QMqtt Module"),(0,o.kt)("p",null,"The mqtt library is not a part of standard Qt build. You need to install this module on your own, you can find it ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/qt/qtmqtt"},"here"),".\nOnce you get the repository we recommend to build it with relWithDebug options e.g. like that"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo  -DCMAKE_CXX_FLAGS_DEBUG="-O2" .\ncmake --build . --config RelWithDebInfo\ncmake --install . --verbose \n')),(0,o.kt)("h2",{id:"file-overview-for-module"},"File overview for module"),(0,o.kt)("p",null," With an example  API"),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Hello World API (click to expand)"),(0,o.kt)(r.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},i.Z)),(0,o.kt)("p",null,"the following file structure will be generated. The purpose and content of each file is explained below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{4,19}","{4,19}":!0},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2monitor\n \u2503 \u2523 \ud83d\udcc2mqtt\n \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2523 \ud83d\udcdcmqttclient.cpp\n \u2503 \u2503 \u2523 \ud83d\udcdcmqttclient.h\n \u2503 \u2503 \u2523 \ud83d\udcdcmqttservice.cpp\n \u2503 \u2503 \u2523 \ud83d\udcdcmqttservice.h\n \u2503 \u2503 \u2523 ... (helper files)\n \u2503 ...\n \u2523 \ud83d\udcc2qt_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2io_world\n \u2503 \u2503 \u2523 \ud83d\udcc2api\n \u2503 \u2503 \u2523 \ud83d\udcc2implementation\n \u2503 \u2503 \u2523 \ud83d\udcc2monitor\n \u2503 \u2503 \u2523 \ud83d\udcc2mqtt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqtt_common.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttfactory.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttfactory.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqtthello.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqtthello.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqtthelloadapter.cpp\n \u2503 \u2503 \u2503 \u2517 \ud83d\udcdcmqtthelloadapter.h\n ...\n")),(0,o.kt)("h3",{id:"qt-apigear---the-network-layer"},"Qt apigear - The Network Layer"),(0,o.kt)("p",null,"When generating the mqtt feature (or any of those: olink monitor feature) you'll get an additional folder it the top most directory: the \ud83d\udcc2hello-world/\ud83d\udcc2apigear. The \ud83d\udcc2mqtt subfolder contains objects that implement a network layer (based on Qt Mqtt library) for the MQTT protocol. Those are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Client - Adapts the Qt MQTT client, to serve as an network endpoint for ",(0,o.kt)("a",{parentName:"li",href:"mqtt#MQTT-Client-Adapter"},"interface client adapters"),".\nExposes methods that allow receiving data for remote service: subscribing for properties changes, signals emission and method response invocation;\nmethods that allow remote using the service: requesting property change or invoking a method. The client may serve many client interface adapters, even for the same interfaces (allows subscribing for same topic).\nIn case many interface clients adapters for some interface are connected: property changes and signals are provided to all interface client adapters, but the invoke method response will be delivered only for the one that requested it."),(0,o.kt)("li",{parentName:"ul"},"ServiceAdapter - Adapts the Qt MQTT client to serve as an network endpoint for ",(0,o.kt)("a",{parentName:"li",href:"mqtt#MQTT-Server-Adapter"},"interface service adapters"),". Exposes methods that allow receiving requests from remote clients: subscribing for properties change requests, send method invocation;\nmethods that allow publishing property change, signal, functionality to handles sending a response for method invocation requests. This ServiceAdapter may be used for many interface service adapters, but it is not recommended to use more than one interface service adapter for same interface.")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Have in mind that MQTT might not be suitable for high-frequency messages especially with one mqtt client serving more than one object.\nAlso the brokers have limits for messages number/size queued from one client. In case you are not getting all the messages consider changing those or splitting traffic between more clients (maybe some handle the properties, some handle the methods).")),(0,o.kt)("h3",{id:"mqtt-client-adapter"},"MQTT Client Adapter"),(0,o.kt)("p",null,"Files ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqtthello.h")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqtthello.cpp")," implement the remote client for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," interface  - a ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttHello")," class.",(0,o.kt)("br",null),"\nThe object is an ",(0,o.kt)("inlineCode",{parentName:"p"},"AbstractHello")," implementation.",(0,o.kt)("br",null),"\nIt requires an instance of Apigear::Mqtt::Client to work.  It uses the Client to subscribe (and unsubscribe) for topics that allow receiving properties, signals and invoke responses from service."),(0,o.kt)("h4",{id:"properties"},"Properties"),(0,o.kt)("p",null,"The property getters (here ",(0,o.kt)("inlineCode",{parentName:"p"},"Message last()")," ) return immediately the locally stored last received value from server. ",(0,o.kt)("br",null),"\nThe property setter (here ",(0,o.kt)("inlineCode",{parentName:"p"},"void setLast(const Message& last)")," ) requests setting a value on server side, local value is not changed. ",(0,o.kt)("br",null),"\nYou can connect to a property changed signals (here ",(0,o.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)")," )\nWhen the client receives information that server changed the property, a target property (here ",(0,o.kt)("inlineCode",{parentName:"p"},"last"),") is updated locally and a signal that property has changed is emitted ( here ",(0,o.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The connected interface client adapter has its local properties in sync with a service. The properties messages are retained in mqtt broker, so all already set properties are provided.")),(0,o.kt)("h4",{id:"operations"},"Operations"),(0,o.kt)("p",null,"The operations have additionally the async version, which is called by the immediate version.",(0,o.kt)("br",null),"\nThe async version sends an invoke operation request to a server.",(0,o.kt)("br",null),"\nSo calling ",(0,o.kt)("inlineCode",{parentName:"p"},"myMqttHelloInstance.say(myWhen)")," implements execution of ",(0,o.kt)("inlineCode",{parentName:"p"},"sayAsync")," and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation."),(0,o.kt)("h4",{id:"signals"},"Signals"),(0,o.kt)("p",null,"You should not emit any signals from a client.\nYou can connect to any signals offered by your interface (here ",(0,o.kt)("inlineCode",{parentName:"p"},"void justSaid(const Message& msg)")," )\nWhen a MqttHello client receives the message from server that indicates the signal was emitted it emits a signal (here ",(0,o.kt)("inlineCode",{parentName:"p"},"justSaid"),")."),(0,o.kt)("h4",{id:"use-mqtthello"},"Use ",(0,o.kt)("inlineCode",{parentName:"h4"},"MqttHello")),(0,o.kt)("p",null,"As mentioned earlier you an adapter of QtMqtt (with protcol and network layer implementation), here provided by a ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiGear::Mqtt::Client"),". All you need to do is to pass this Client to your Interface Client Adapter, and request connecting to host when it is convenient for you."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'    // Create a client and make a connection\n    ApiGear::Mqtt::Client client("UniqueClientName");\n    client.connectToHost("localhost", 1883); // Use the same port number as your broker is using. Typically, without any other settings it is "1883".\n\n    // Create your service client.\n    auto ioWorldHello = std::make_shared<io_world::MqttHello>(client);\n\n    // use your ioWorldHello as it was Hello implementation\n    ioWorldHello.say(someWhen);\n    auto lastMessage = ioWorldHello->last();\n    ioWorldHello->setLast(someMessage);\n    ioWorldHello->connect(ioWorldHello.get(), &io_world::AbstractHello::justSaid, *otherObject, &SomeJustSaidUser::handleJustSaid);\n')),(0,o.kt)("h3",{id:"mqtt-server-adapter"},"MQTT Server Adapter"),(0,o.kt)("p",null,"Files ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqtthelloadapter.h")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqtthelloadapter.h")," contain the mqtt server side adapter for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," interface - the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttHelloAdapter")," class.",(0,o.kt)("br",null),"\nWhen creating the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttHelloAdapter")," you need to provide the Apigear::Mqtt::ServiceAdapter and the local ",(0,o.kt)("inlineCode",{parentName:"p"},"AbstractHello")," service object, you want to expose to clients.",(0,o.kt)("br",null),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"MqttHelloAdapter")," object exposes the local object for remote usage with the MQTT protocol. It handles all the network requests, and calls your local object.\nThe client connections and communication with them is handled transparently for you, no additional actions are needed."),(0,o.kt)("h4",{id:"properties-1"},"Properties"),(0,o.kt)("p",null,"Each time a property changed signal (here ",(0,o.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)")," ) is emitted, a message is sent to all connected clients with information, which property changed to which value. This may occur either when you change a property directly on your local ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," object, or when a change property request message is received by the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttHelloAdapter"),", which applies the property on your local ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," object."),(0,o.kt)("h4",{id:"operations-1"},"Operations"),(0,o.kt)("p",null,"The operations invocation which came from the clients through the network will be performed on your local ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," object. The result of the operation (if any) will be returned only to a client, from which the message was send, not all clients."),(0,o.kt)("h4",{id:"signals-1"},"Signals"),(0,o.kt)("p",null,"All the signals emitted by your local ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello")," objects are forwarded to all connected clients."),(0,o.kt)("h4",{id:"use-mqtthelloadapter"},"Use ",(0,o.kt)("inlineCode",{parentName:"h4"},"MqttHelloAdapter")),(0,o.kt)("p",null,"As mentioned earlier you an adapter of QtMqtt (with protcol and network layer implementation), here provided by a ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiGear::Mqtt::ServiceAdapter"),"\nAll you need to do is to pass this ServiceAdapter to your Interface Service Adapter, and request connecting to host when it is convenient for you."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'\n    // Prepare the Mqtt Service Adapter and an object which you want to expose.\n    ApiGear::Mqtt::ServiceAdapter service("ServiceUniqueNameInMqtt");\n    service.connectToHost("localhost", 1883);  // Use the same port number as your broker is using. Typically, without any other settings it is "1883".\n    auto ioWorldHello = std::make_shared<io_world::Hello>();\n\n    // Create your MqttHelloAdapter and add it to registry.\n    auto ioWorldMqttHelloService = std::make_shared<io_world::MqttHelloAdapter>(service, ioWorldHello);\n\n    // use your ioWorldHello as it was Hello implementation, all property changes, and signals will be passed to connected MqttHello clients.\n    ioWorldHello.say(someWhen);\n    auto lastMessage = ioWorldHello->last();\n    ioWorldHello->setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value.\n    ioWorldHello->connect(ioWorldHello.get(), &io_world::AbstractHello::justSaid, *otherObject, &SomeJustSaidUser::handleJustSaid);\n\n')),(0,o.kt)("h3",{id:"mqtt-factory---for-qml-usage"},"MQTT Factory - for QML usage"),(0,o.kt)("p",null,"Files ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqttfactory.h"),"  and ",(0,o.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcmqttfactory.cpp")," contain the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttFactory")," which creates the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttClient")," version of your interfaces (returned as a",(0,o.kt)("inlineCode",{parentName:"p"},"AbstractHello")," interfaces). ",(0,o.kt)("br",null),"\nThe factory is necessary when you want to use the MqttClient implementation version for the ",(0,o.kt)("a",{parentName:"p",href:"api#qml-wrappers"},"QML wrapper"),". You need to set the ",(0,o.kt)("inlineCode",{parentName:"p"},"MqttFactory")," as an API factory. See more details ",(0,o.kt)("a",{parentName:"p",href:"api#providing-backend-to-qml-wrapper"},"on providing backend to QML wrapper")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'    // Prepare Factory before app is created.\n    ApiGear::Mqtt::Client client("UniqueClientForQmlExample");\n    io_world::MqttFactory io_worldMqttFactory(client);\n    io_world::ApiFactory::set(&io_worldMqttFactory);\n    ...\n\n    client.connectToHost("localhost", 1883);\n')),(0,o.kt)("p",null,"The factory uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkClient")," and links the objects when they are created, you don't have to perform any other actions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-qml"},"...\nimport io_world 1.0\n\nApplicationWindow {\n...\n            Button {\n            width: 80\n            height: 80\n            text: qmlIoWorldHello.last.content\n            onClicked: {\n                qmlIoWorldHello.say(someMessage, someWhen)\n            }\n        }\n    IoWorldHello { id: qmlIoWorldHello }\n...\n}\n")),(0,o.kt)("h3",{id:"mqtt-messages"},"MQTT Messages"),(0,o.kt)("p",null,"In case you want construct messages for client or server side on your own, please check how topics are created and how does the payload look like, check this documentS ",(0,o.kt)("a",{target:"_blank",href:n(5753).Z},"messages format"),"."))}u.isMDXComponent=!0},5753:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/ApiGearMQTTv0.1-2a3f7ef573c506e85e1be8ce33178064.pdf"}}]);